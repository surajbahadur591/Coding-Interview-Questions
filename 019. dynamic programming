dynamic programming 

2 property :
optimal substructure - use sub problem to solve 
overlapping sub problem - reuse sub problem

ex : fibonacci
use solution n-2 and n-1 to solve n

solution using dynamic programming

top down = recursion + memorization 
bottom up = tabulation (actual dynamic programming)

first solve smaller sub problems and then using those smaller sub problem solve bigger sub problem

fib[]- [1, 1, .... ]
fib[n]= fib[n-1] + fib[n-2]

problem 1 - climbing steps : we can climb 1 , 3 , 5 steps at a time. how manny ways are there to get to the top of the steps

problem 2 - coin change : make 5 $ 
    you have  coins -> {1, 2, 5} in how many ways you can make 5$

 

